'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mongoose = require('mongoose');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var normalize = function normalize(value) {
  return _lodash2.default.kebabCase(value).replace(/\-/g, ' ');
};

var keywordsPlugin = function keywordsPlugin(schema) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      paths = _ref.paths,
      _ref$field = _ref.field,
      field = _ref$field === undefined ? 'keywords' : _ref$field,
      _ref$transform = _ref.transform,
      transform = _ref$transform === undefined ? normalize : _ref$transform;

  paths = paths && paths.map(function (p) {
    return schema.path(p);
  });

  if (!paths || !paths.length) return;

  schema.add(_defineProperty({}, field, _lodash2.default.assign({}, schema.tree[field], {
    type: [String],
    index: true
  })));

  paths.forEach(function (path) {
    schema.path(path.path).set(function (value) {
      var _this = this;

      if (this instanceof _mongoose.Query) {
        return value;
      }
      var oldValue = this[path.path];

      if (value === oldValue) return value;

      var parsePath = function parsePath(path, value) {
        // on create - document might not be populated
        if (_this[field]) {
          if (path instanceof _mongoose.SchemaTypes.ObjectId) {
            value[field] && value[field].forEach(function (keyword) {
              var _field;

              oldValue && oldValue[field] && (_field = _this[field]).pull.apply(_field, _toConsumableArray(oldValue[field]));
              _this[field].addToSet(keyword);
            });
          } else {
            oldValue && _this[field].pull(transform(oldValue));
            _this[field].addToSet(transform(value));
          }
        }
      };

      if (path instanceof _mongoose.SchemaTypes.Array) {
        value.forEach(function (val) {
          parsePath(path.caster, val);
        });
      } else {
        parsePath(path, value);
      }

      return value;
    });
  });
};

exports.default = keywordsPlugin;


module.exports = exports = keywordsPlugin;